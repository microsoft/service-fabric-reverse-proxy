// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: network/http_connection_manager/v2/http_connection_manager.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Filter.Network.HttpConnectionManager.V2 {

  /// <summary>Holder for reflection information generated from network/http_connection_manager/v2/http_connection_manager.proto</summary>
  public static partial class HttpConnectionManagerReflection {

    #region Descriptor
    /// <summary>File descriptor for network/http_connection_manager/v2/http_connection_manager.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static HttpConnectionManagerReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkBuZXR3b3JrL2h0dHBfY29ubmVjdGlvbl9tYW5hZ2VyL3YyL2h0dHBfY29u",
            "bmVjdGlvbl9tYW5hZ2VyLnByb3RvEjZlbnZveS5jb25maWcuZmlsdGVyLm5l",
            "dHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjIaHGVudm95L2FwaS92",
            "Mi9jb3JlL2Jhc2UucHJvdG8aJWVudm95L2FwaS92Mi9jb3JlL2NvbmZpZ19z",
            "b3VyY2UucHJvdG8aIGVudm95L2FwaS92Mi9jb3JlL3Byb3RvY29sLnByb3Rv",
            "GjBlbnZveS9jb25maWcvZmlsdGVyL2FjY2Vzc2xvZy92Mi9hY2Nlc3Nsb2cu",
            "cHJvdG8aFmVudm95L2FwaS92Mi9yZHMucHJvdG8aHmdvb2dsZS9wcm90b2J1",
            "Zi9kdXJhdGlvbi5wcm90bxocZ29vZ2xlL3Byb3RvYnVmL3N0cnVjdC5wcm90",
            "bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGhd2YWxpZGF0ZS92",
            "YWxpZGF0ZS5wcm90bxoUZ29nb3Byb3RvL2dvZ28ucHJvdG8i8RAKFUh0dHBD",
            "b25uZWN0aW9uTWFuYWdlchJ3Cgpjb2RlY190eXBlGAEgASgOMlcuZW52b3ku",
            "Y29uZmlnLmZpbHRlci5uZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2Vy",
            "LnYyLkh0dHBDb25uZWN0aW9uTWFuYWdlci5Db2RlY1R5cGVCCrrpwAMFggEC",
            "EAESHgoLc3RhdF9wcmVmaXgYAiABKAlCCbrpwAMEcgIgARJKCgNyZHMYAyAB",
            "KAsyOy5lbnZveS5jb25maWcuZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25uZWN0",
            "aW9uX21hbmFnZXIudjIuUmRzSAASOAoMcm91dGVfY29uZmlnGAQgASgLMiAu",
            "ZW52b3kuYXBpLnYyLlJvdXRlQ29uZmlndXJhdGlvbkgAElgKDGh0dHBfZmls",
            "dGVycxgFIAMoCzJCLmVudm95LmNvbmZpZy5maWx0ZXIubmV0d29yay5odHRw",
            "X2Nvbm5lY3Rpb25fbWFuYWdlci52Mi5IdHRwRmlsdGVyEjIKDmFkZF91c2Vy",
            "X2FnZW50GAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRJmCgd0",
            "cmFjaW5nGAcgASgLMlUuZW52b3kuY29uZmlnLmZpbHRlci5uZXR3b3JrLmh0",
            "dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYyLkh0dHBDb25uZWN0aW9uTWFuYWdl",
            "ci5UcmFjaW5nEkYKFWh0dHBfcHJvdG9jb2xfb3B0aW9ucxgIIAEoCzInLmVu",
            "dm95LmFwaS52Mi5jb3JlLkh0dHAxUHJvdG9jb2xPcHRpb25zEkcKFmh0dHAy",
            "X3Byb3RvY29sX29wdGlvbnMYCSABKAsyJy5lbnZveS5hcGkudjIuY29yZS5I",
            "dHRwMlByb3RvY29sT3B0aW9ucxITCgtzZXJ2ZXJfbmFtZRgKIAEoCRI1Cgxp",
            "ZGxlX3RpbWVvdXQYCyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25C",
            "BJjfHwESNgoNZHJhaW5fdGltZW91dBgMIAEoCzIZLmdvb2dsZS5wcm90b2J1",
            "Zi5EdXJhdGlvbkIEmN8fARI/CgphY2Nlc3NfbG9nGA0gAygLMisuZW52b3ku",
            "Y29uZmlnLmZpbHRlci5hY2Nlc3Nsb2cudjIuQWNjZXNzTG9nEjYKEnVzZV9y",
            "ZW1vdGVfYWRkcmVzcxgOIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFs",
            "dWUSHAoUeGZmX251bV90cnVzdGVkX2hvcHMYEyABKA0SNwoTZ2VuZXJhdGVf",
            "cmVxdWVzdF9pZBgPIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUS",
            "lwEKG2ZvcndhcmRfY2xpZW50X2NlcnRfZGV0YWlscxgQIAEoDjJmLmVudm95",
            "LmNvbmZpZy5maWx0ZXIubmV0d29yay5odHRwX2Nvbm5lY3Rpb25fbWFuYWdl",
            "ci52Mi5IdHRwQ29ubmVjdGlvbk1hbmFnZXIuRm9yd2FyZENsaWVudENlcnRE",
            "ZXRhaWxzQgq66cADBYIBAhABEpIBCh9zZXRfY3VycmVudF9jbGllbnRfY2Vy",
            "dF9kZXRhaWxzGBEgASgLMmkuZW52b3kuY29uZmlnLmZpbHRlci5uZXR3b3Jr",
            "Lmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYyLkh0dHBDb25uZWN0aW9uTWFu",
            "YWdlci5TZXRDdXJyZW50Q2xpZW50Q2VydERldGFpbHMSGgoScHJveHlfMTAw",
            "X2NvbnRpbnVlGBIgASgIEjkKMXJlcHJlc2VudF9pcHY0X3JlbW90ZV9hZGRy",
            "ZXNzX2FzX2lwdjRfbWFwcGVkX2lwdjYYFCABKAgahQMKB1RyYWNpbmcShwEK",
            "Dm9wZXJhdGlvbl9uYW1lGAEgASgOMmMuZW52b3kuY29uZmlnLmZpbHRlci5u",
            "ZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYyLkh0dHBDb25uZWN0",
            "aW9uTWFuYWdlci5UcmFjaW5nLk9wZXJhdGlvbk5hbWVCCrrpwAMFggECEAES",
            "IAoYcmVxdWVzdF9oZWFkZXJzX2Zvcl90YWdzGAIgAygJEjMKD2NsaWVudF9z",
            "YW1wbGluZxgDIAEoCzIaLmVudm95LmFwaS52Mi5jb3JlLlBlcmNlbnQSMwoP",
            "cmFuZG9tX3NhbXBsaW5nGAQgASgLMhouZW52b3kuYXBpLnYyLmNvcmUuUGVy",
            "Y2VudBI0ChBvdmVyYWxsX3NhbXBsaW5nGAUgASgLMhouZW52b3kuYXBpLnYy",
            "LmNvcmUuUGVyY2VudCIuCg1PcGVyYXRpb25OYW1lEgsKB0lOR1JFU1MQABIK",
            "CgZFR1JFU1MQARoEiKMeABqBAQobU2V0Q3VycmVudENsaWVudENlcnREZXRh",
            "aWxzEisKB3N1YmplY3QYASABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZh",
            "bHVlEicKA3NhbhgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUS",
            "DAoEY2VydBgDIAEoCCIxCglDb2RlY1R5cGUSCAoEQVVUTxAAEgkKBUhUVFAx",
            "EAESCQoFSFRUUDIQAhoEiKMeACJ/ChhGb3J3YXJkQ2xpZW50Q2VydERldGFp",
            "bHMSDAoIU0FOSVRJWkUQABIQCgxGT1JXQVJEX09OTFkQARISCg5BUFBFTkRf",
            "Rk9SV0FSRBACEhAKDFNBTklUSVpFX1NFVBADEhcKE0FMV0FZU19GT1JXQVJE",
            "X09OTFkQBBoEiKMeAEIYCg9yb3V0ZV9zcGVjaWZpZXISBbjpwAMBInMKA1Jk",
            "cxJGCg1jb25maWdfc291cmNlGAEgASgLMh8uZW52b3kuYXBpLnYyLmNvcmUu",
            "Q29uZmlnU291cmNlQg666cADBYoBAhAByN4fABIkChFyb3V0ZV9jb25maWdf",
            "bmFtZRgCIAEoCUIJuunAAwRyAiABItgBCgpIdHRwRmlsdGVyEhcKBG5hbWUY",
            "ASABKAlCCbrpwAMEcgIgARInCgZjb25maWcYAiABKAsyFy5nb29nbGUucHJv",
            "dG9idWYuU3RydWN0EmoKDWRlcHJlY2F0ZWRfdjEYAyABKAsyTy5lbnZveS5j",
            "b25maWcuZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIu",
            "djIuSHR0cEZpbHRlci5EZXByZWNhdGVkVjFCAhgBGhwKDERlcHJlY2F0ZWRW",
            "MRIMCgR0eXBlGAEgASgJQgRaAnYyYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Api.V2.Core.ConfigSourceReflection.Descriptor, global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor, global::Envoy.Config.Filter.Accesslog.V2.AccesslogReflection.Descriptor, global::Envoy.Api.V2.RdsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, global::Gogoproto.GogoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager), global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Parser, new[]{ "CodecType", "StatPrefix", "Rds", "RouteConfig", "HttpFilters", "AddUserAgent", "Tracing", "HttpProtocolOptions", "Http2ProtocolOptions", "ServerName", "IdleTimeout", "DrainTimeout", "AccessLog", "UseRemoteAddress", "XffNumTrustedHops", "GenerateRequestId", "ForwardClientCertDetails", "SetCurrentClientCertDetails", "Proxy100Continue", "RepresentIpv4RemoteAddressAsIpv4MappedIpv6" }, new[]{ "RouteSpecifier" }, new[]{ typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.CodecType), typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.ForwardClientCertDetails) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.Tracing), global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.Tracing.Parser, new[]{ "OperationName", "RequestHeadersForTags", "ClientSampling", "RandomSampling", "OverallSampling" }, null, new[]{ typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.Tracing.Types.OperationName) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.SetCurrentClientCertDetails), global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.SetCurrentClientCertDetails.Parser, new[]{ "Subject", "San", "Cert" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.Rds), global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.Rds.Parser, new[]{ "ConfigSource", "RouteConfigName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter), global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter.Parser, new[]{ "Name", "Config", "DeprecatedV1" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter.Types.DeprecatedV1), global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter.Types.DeprecatedV1.Parser, new[]{ "Type" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#comment:next free field: 21]
  /// </summary>
  public sealed partial class HttpConnectionManager : pb::IMessage<HttpConnectionManager> {
    private static readonly pb::MessageParser<HttpConnectionManager> _parser = new pb::MessageParser<HttpConnectionManager>(() => new HttpConnectionManager());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HttpConnectionManager> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManagerReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpConnectionManager() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpConnectionManager(HttpConnectionManager other) : this() {
      codecType_ = other.codecType_;
      statPrefix_ = other.statPrefix_;
      httpFilters_ = other.httpFilters_.Clone();
      AddUserAgent = other.AddUserAgent;
      Tracing = other.tracing_ != null ? other.Tracing.Clone() : null;
      HttpProtocolOptions = other.httpProtocolOptions_ != null ? other.HttpProtocolOptions.Clone() : null;
      Http2ProtocolOptions = other.http2ProtocolOptions_ != null ? other.Http2ProtocolOptions.Clone() : null;
      serverName_ = other.serverName_;
      IdleTimeout = other.idleTimeout_ != null ? other.IdleTimeout.Clone() : null;
      DrainTimeout = other.drainTimeout_ != null ? other.DrainTimeout.Clone() : null;
      accessLog_ = other.accessLog_.Clone();
      UseRemoteAddress = other.UseRemoteAddress;
      xffNumTrustedHops_ = other.xffNumTrustedHops_;
      GenerateRequestId = other.GenerateRequestId;
      forwardClientCertDetails_ = other.forwardClientCertDetails_;
      SetCurrentClientCertDetails = other.setCurrentClientCertDetails_ != null ? other.SetCurrentClientCertDetails.Clone() : null;
      proxy100Continue_ = other.proxy100Continue_;
      representIpv4RemoteAddressAsIpv4MappedIpv6_ = other.representIpv4RemoteAddressAsIpv4MappedIpv6_;
      switch (other.RouteSpecifierCase) {
        case RouteSpecifierOneofCase.Rds:
          Rds = other.Rds.Clone();
          break;
        case RouteSpecifierOneofCase.RouteConfig:
          RouteConfig = other.RouteConfig.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpConnectionManager Clone() {
      return new HttpConnectionManager(this);
    }

    /// <summary>Field number for the "codec_type" field.</summary>
    public const int CodecTypeFieldNumber = 1;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.CodecType codecType_ = 0;
    /// <summary>
    /// Supplies the type of codec that the connection manager should use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.CodecType CodecType {
      get { return codecType_; }
      set {
        codecType_ = value;
      }
    }

    /// <summary>Field number for the "stat_prefix" field.</summary>
    public const int StatPrefixFieldNumber = 2;
    private string statPrefix_ = "";
    /// <summary>
    /// The human readable prefix to use when emitting statistics for the
    /// connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats>` for
    /// more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StatPrefix {
      get { return statPrefix_; }
      set {
        statPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "rds" field.</summary>
    public const int RdsFieldNumber = 3;
    /// <summary>
    /// The connection manager’s route table will be dynamically loaded via the RDS API.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.Rds Rds {
      get { return routeSpecifierCase_ == RouteSpecifierOneofCase.Rds ? (global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.Rds) routeSpecifier_ : null; }
      set {
        routeSpecifier_ = value;
        routeSpecifierCase_ = value == null ? RouteSpecifierOneofCase.None : RouteSpecifierOneofCase.Rds;
      }
    }

    /// <summary>Field number for the "route_config" field.</summary>
    public const int RouteConfigFieldNumber = 4;
    /// <summary>
    /// The route table for the connection manager is static and is specified in this property.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.RouteConfiguration RouteConfig {
      get { return routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig ? (global::Envoy.Api.V2.RouteConfiguration) routeSpecifier_ : null; }
      set {
        routeSpecifier_ = value;
        routeSpecifierCase_ = value == null ? RouteSpecifierOneofCase.None : RouteSpecifierOneofCase.RouteConfig;
      }
    }

    /// <summary>Field number for the "http_filters" field.</summary>
    public const int HttpFiltersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter> _repeated_httpFilters_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter> httpFilters_ = new pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter>();
    /// <summary>
    /// A list of individual HTTP filters that make up the filter chain for
    /// requests made to the connection manager. Order matters as the filters are
    /// processed sequentially as request events happen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter> HttpFilters {
      get { return httpFilters_; }
    }

    /// <summary>Field number for the "add_user_agent" field.</summary>
    public const int AddUserAgentFieldNumber = 6;
    private static readonly pb::FieldCodec<bool?> _single_addUserAgent_codec = pb::FieldCodec.ForStructWrapper<bool>(50);
    private bool? addUserAgent_;
    /// <summary>
    /// Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
    /// and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
    /// documentation for more information. Defaults to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? AddUserAgent {
      get { return addUserAgent_; }
      set {
        addUserAgent_ = value;
      }
    }

    /// <summary>Field number for the "tracing" field.</summary>
    public const int TracingFieldNumber = 7;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.Tracing tracing_;
    /// <summary>
    /// Presence of the object defines whether the connection manager
    /// emits :ref:`tracing &lt;arch_overview_tracing>` data to the :ref:`configured tracing provider
    /// &lt;envoy_api_msg_config.trace.v2.Tracing>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.Tracing Tracing {
      get { return tracing_; }
      set {
        tracing_ = value;
      }
    }

    /// <summary>Field number for the "http_protocol_options" field.</summary>
    public const int HttpProtocolOptionsFieldNumber = 8;
    private global::Envoy.Api.V2.Core.Http1ProtocolOptions httpProtocolOptions_;
    /// <summary>
    /// Additional HTTP/1 settings that are passed to the HTTP/1 codec.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Http1ProtocolOptions HttpProtocolOptions {
      get { return httpProtocolOptions_; }
      set {
        httpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 9;
    private global::Envoy.Api.V2.Core.Http2ProtocolOptions http2ProtocolOptions_;
    /// <summary>
    /// Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "server_name" field.</summary>
    public const int ServerNameFieldNumber = 10;
    private string serverName_ = "";
    /// <summary>
    /// An optional override that the connection manager will write to the server
    /// header in responses. If not set, the default is *envoy*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ServerName {
      get { return serverName_; }
      set {
        serverName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "idle_timeout" field.</summary>
    public const int IdleTimeoutFieldNumber = 11;
    private global::Google.Protobuf.WellKnownTypes.Duration idleTimeout_;
    /// <summary>
    /// The idle timeout for connections managed by the connection manager. The
    /// idle timeout is defined as the period in which there are no active
    /// requests. If not set, there is no idle timeout. When the idle timeout is
    /// reached the connection will be closed. If the connection is an HTTP/2
    /// connection a drain sequence will occur prior to closing the connection. See
    /// :ref:`drain_timeout
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration IdleTimeout {
      get { return idleTimeout_; }
      set {
        idleTimeout_ = value;
      }
    }

    /// <summary>Field number for the "drain_timeout" field.</summary>
    public const int DrainTimeoutFieldNumber = 12;
    private global::Google.Protobuf.WellKnownTypes.Duration drainTimeout_;
    /// <summary>
    /// The time that Envoy will wait between sending an HTTP/2 “shutdown
    /// notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
    /// This is used so that Envoy provides a grace period for new streams that
    /// race with the final GOAWAY frame. During this grace period, Envoy will
    /// continue to accept new streams. After the grace period, a final GOAWAY
    /// frame is sent and Envoy will start refusing new streams. Draining occurs
    /// both when a connection hits the idle timeout or during general server
    /// draining. The default grace period is 5000 milliseconds (5 seconds) if this
    /// option is not specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration DrainTimeout {
      get { return drainTimeout_; }
      set {
        drainTimeout_ = value;
      }
    }

    /// <summary>Field number for the "access_log" field.</summary>
    public const int AccessLogFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Config.Filter.Accesslog.V2.AccessLog> _repeated_accessLog_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Config.Filter.Accesslog.V2.AccessLog.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Filter.Accesslog.V2.AccessLog> accessLog_ = new pbc::RepeatedField<global::Envoy.Config.Filter.Accesslog.V2.AccessLog>();
    /// <summary>
    /// Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs>`
    /// emitted by the connection manager.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Filter.Accesslog.V2.AccessLog> AccessLog {
      get { return accessLog_; }
    }

    /// <summary>Field number for the "use_remote_address" field.</summary>
    public const int UseRemoteAddressFieldNumber = 14;
    private static readonly pb::FieldCodec<bool?> _single_useRemoteAddress_codec = pb::FieldCodec.ForStructWrapper<bool>(114);
    private bool? useRemoteAddress_;
    /// <summary>
    /// If set to true, the connection manager will use the real remote address
    /// of the client connection when determining internal versus external origin and manipulating
    /// various headers. If set to false or absent, the connection manager will use the
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
    /// :ref:`config_http_conn_man_headers_x-forwarded-for`,
    /// :ref:`config_http_conn_man_headers_x-envoy-internal`, and
    /// :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? UseRemoteAddress {
      get { return useRemoteAddress_; }
      set {
        useRemoteAddress_ = value;
      }
    }

    /// <summary>Field number for the "xff_num_trusted_hops" field.</summary>
    public const int XffNumTrustedHopsFieldNumber = 19;
    private uint xffNumTrustedHops_;
    /// <summary>
    /// The number of additional ingress proxy hops from the right side of the
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
    /// determining the origin client's IP address. The default is zero if this option
    /// is not specified. See the documentation for
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint XffNumTrustedHops {
      get { return xffNumTrustedHops_; }
      set {
        xffNumTrustedHops_ = value;
      }
    }

    /// <summary>Field number for the "generate_request_id" field.</summary>
    public const int GenerateRequestIdFieldNumber = 15;
    private static readonly pb::FieldCodec<bool?> _single_generateRequestId_codec = pb::FieldCodec.ForStructWrapper<bool>(122);
    private bool? generateRequestId_;
    /// <summary>
    /// of the client connection as the origin client address if *use_remote_address* is true
    /// Whether the connection manager will generate the :ref:`x-request-id
    /// &lt;config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
    /// true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
    /// is not desired it can be disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? GenerateRequestId {
      get { return generateRequestId_; }
      set {
        generateRequestId_ = value;
      }
    }

    /// <summary>Field number for the "forward_client_cert_details" field.</summary>
    public const int ForwardClientCertDetailsFieldNumber = 16;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.ForwardClientCertDetails forwardClientCertDetails_ = 0;
    /// <summary>
    /// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
    /// header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.ForwardClientCertDetails ForwardClientCertDetails {
      get { return forwardClientCertDetails_; }
      set {
        forwardClientCertDetails_ = value;
      }
    }

    /// <summary>Field number for the "set_current_client_cert_details" field.</summary>
    public const int SetCurrentClientCertDetailsFieldNumber = 17;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.SetCurrentClientCertDetails setCurrentClientCertDetails_;
    /// <summary>
    /// This field is valid only when :ref:`forward_client_cert_details
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.forward_client_cert_details>`
    /// is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
    /// the client certificate to be forwarded. Note that in the
    /// :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
    /// *By* is always set when the client certificate presents the SAN value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.SetCurrentClientCertDetails SetCurrentClientCertDetails {
      get { return setCurrentClientCertDetails_; }
      set {
        setCurrentClientCertDetails_ = value;
      }
    }

    /// <summary>Field number for the "proxy_100_continue" field.</summary>
    public const int Proxy100ContinueFieldNumber = 18;
    private bool proxy100Continue_;
    /// <summary>
    /// If proxy_100_continue is true, Envoy will proxy incoming "Expect:
    /// 100-continue" headers upstream, and forward "100 Continue" responses
    /// downstream. If this is false or not set, Envoy will instead strip the
    /// "Expect: 100-continue" header, and send a "100 Continue" response itself.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Proxy100Continue {
      get { return proxy100Continue_; }
      set {
        proxy100Continue_ = value;
      }
    }

    /// <summary>Field number for the "represent_ipv4_remote_address_as_ipv4_mapped_ipv6" field.</summary>
    public const int RepresentIpv4RemoteAddressAsIpv4MappedIpv6FieldNumber = 20;
    private bool representIpv4RemoteAddressAsIpv4MappedIpv6_;
    /// <summary>
    /// If
    /// :ref:`use_remote_address
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.use_remote_address>`
    /// is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
    /// an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
    /// This is useful for testing compatibility of upstream services that parse the header value. For
    /// example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
    /// &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
    /// :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
    /// :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
    /// &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
    /// control.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool RepresentIpv4RemoteAddressAsIpv4MappedIpv6 {
      get { return representIpv4RemoteAddressAsIpv4MappedIpv6_; }
      set {
        representIpv4RemoteAddressAsIpv4MappedIpv6_ = value;
      }
    }

    private object routeSpecifier_;
    /// <summary>Enum of possible cases for the "route_specifier" oneof.</summary>
    public enum RouteSpecifierOneofCase {
      None = 0,
      Rds = 3,
      RouteConfig = 4,
    }
    private RouteSpecifierOneofCase routeSpecifierCase_ = RouteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteSpecifierOneofCase RouteSpecifierCase {
      get { return routeSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRouteSpecifier() {
      routeSpecifierCase_ = RouteSpecifierOneofCase.None;
      routeSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HttpConnectionManager);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HttpConnectionManager other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CodecType != other.CodecType) return false;
      if (StatPrefix != other.StatPrefix) return false;
      if (!object.Equals(Rds, other.Rds)) return false;
      if (!object.Equals(RouteConfig, other.RouteConfig)) return false;
      if(!httpFilters_.Equals(other.httpFilters_)) return false;
      if (AddUserAgent != other.AddUserAgent) return false;
      if (!object.Equals(Tracing, other.Tracing)) return false;
      if (!object.Equals(HttpProtocolOptions, other.HttpProtocolOptions)) return false;
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      if (ServerName != other.ServerName) return false;
      if (!object.Equals(IdleTimeout, other.IdleTimeout)) return false;
      if (!object.Equals(DrainTimeout, other.DrainTimeout)) return false;
      if(!accessLog_.Equals(other.accessLog_)) return false;
      if (UseRemoteAddress != other.UseRemoteAddress) return false;
      if (XffNumTrustedHops != other.XffNumTrustedHops) return false;
      if (GenerateRequestId != other.GenerateRequestId) return false;
      if (ForwardClientCertDetails != other.ForwardClientCertDetails) return false;
      if (!object.Equals(SetCurrentClientCertDetails, other.SetCurrentClientCertDetails)) return false;
      if (Proxy100Continue != other.Proxy100Continue) return false;
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != other.RepresentIpv4RemoteAddressAsIpv4MappedIpv6) return false;
      if (RouteSpecifierCase != other.RouteSpecifierCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CodecType != 0) hash ^= CodecType.GetHashCode();
      if (StatPrefix.Length != 0) hash ^= StatPrefix.GetHashCode();
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) hash ^= Rds.GetHashCode();
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) hash ^= RouteConfig.GetHashCode();
      hash ^= httpFilters_.GetHashCode();
      if (addUserAgent_ != null) hash ^= AddUserAgent.GetHashCode();
      if (tracing_ != null) hash ^= Tracing.GetHashCode();
      if (httpProtocolOptions_ != null) hash ^= HttpProtocolOptions.GetHashCode();
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      if (ServerName.Length != 0) hash ^= ServerName.GetHashCode();
      if (idleTimeout_ != null) hash ^= IdleTimeout.GetHashCode();
      if (drainTimeout_ != null) hash ^= DrainTimeout.GetHashCode();
      hash ^= accessLog_.GetHashCode();
      if (useRemoteAddress_ != null) hash ^= UseRemoteAddress.GetHashCode();
      if (XffNumTrustedHops != 0) hash ^= XffNumTrustedHops.GetHashCode();
      if (generateRequestId_ != null) hash ^= GenerateRequestId.GetHashCode();
      if (ForwardClientCertDetails != 0) hash ^= ForwardClientCertDetails.GetHashCode();
      if (setCurrentClientCertDetails_ != null) hash ^= SetCurrentClientCertDetails.GetHashCode();
      if (Proxy100Continue != false) hash ^= Proxy100Continue.GetHashCode();
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) hash ^= RepresentIpv4RemoteAddressAsIpv4MappedIpv6.GetHashCode();
      hash ^= (int) routeSpecifierCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CodecType != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) CodecType);
      }
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(StatPrefix);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
        output.WriteRawTag(26);
        output.WriteMessage(Rds);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
        output.WriteRawTag(34);
        output.WriteMessage(RouteConfig);
      }
      httpFilters_.WriteTo(output, _repeated_httpFilters_codec);
      if (addUserAgent_ != null) {
        _single_addUserAgent_codec.WriteTagAndValue(output, AddUserAgent);
      }
      if (tracing_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Tracing);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (ServerName.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(ServerName);
      }
      if (idleTimeout_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(IdleTimeout);
      }
      if (drainTimeout_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(DrainTimeout);
      }
      accessLog_.WriteTo(output, _repeated_accessLog_codec);
      if (useRemoteAddress_ != null) {
        _single_useRemoteAddress_codec.WriteTagAndValue(output, UseRemoteAddress);
      }
      if (generateRequestId_ != null) {
        _single_generateRequestId_codec.WriteTagAndValue(output, GenerateRequestId);
      }
      if (ForwardClientCertDetails != 0) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) ForwardClientCertDetails);
      }
      if (setCurrentClientCertDetails_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(SetCurrentClientCertDetails);
      }
      if (Proxy100Continue != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(Proxy100Continue);
      }
      if (XffNumTrustedHops != 0) {
        output.WriteRawTag(152, 1);
        output.WriteUInt32(XffNumTrustedHops);
      }
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) {
        output.WriteRawTag(160, 1);
        output.WriteBool(RepresentIpv4RemoteAddressAsIpv4MappedIpv6);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CodecType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CodecType);
      }
      if (StatPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StatPrefix);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rds);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RouteConfig);
      }
      size += httpFilters_.CalculateSize(_repeated_httpFilters_codec);
      if (addUserAgent_ != null) {
        size += _single_addUserAgent_codec.CalculateSizeWithTag(AddUserAgent);
      }
      if (tracing_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tracing);
      }
      if (httpProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      if (ServerName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServerName);
      }
      if (idleTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IdleTimeout);
      }
      if (drainTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DrainTimeout);
      }
      size += accessLog_.CalculateSize(_repeated_accessLog_codec);
      if (useRemoteAddress_ != null) {
        size += _single_useRemoteAddress_codec.CalculateSizeWithTag(UseRemoteAddress);
      }
      if (XffNumTrustedHops != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(XffNumTrustedHops);
      }
      if (generateRequestId_ != null) {
        size += _single_generateRequestId_codec.CalculateSizeWithTag(GenerateRequestId);
      }
      if (ForwardClientCertDetails != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ForwardClientCertDetails);
      }
      if (setCurrentClientCertDetails_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SetCurrentClientCertDetails);
      }
      if (Proxy100Continue != false) {
        size += 2 + 1;
      }
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) {
        size += 2 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HttpConnectionManager other) {
      if (other == null) {
        return;
      }
      if (other.CodecType != 0) {
        CodecType = other.CodecType;
      }
      if (other.StatPrefix.Length != 0) {
        StatPrefix = other.StatPrefix;
      }
      httpFilters_.Add(other.httpFilters_);
      if (other.addUserAgent_ != null) {
        if (addUserAgent_ == null || other.AddUserAgent != false) {
          AddUserAgent = other.AddUserAgent;
        }
      }
      if (other.tracing_ != null) {
        if (tracing_ == null) {
          tracing_ = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.Tracing();
        }
        Tracing.MergeFrom(other.Tracing);
      }
      if (other.httpProtocolOptions_ != null) {
        if (httpProtocolOptions_ == null) {
          httpProtocolOptions_ = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
        }
        HttpProtocolOptions.MergeFrom(other.HttpProtocolOptions);
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          http2ProtocolOptions_ = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      if (other.ServerName.Length != 0) {
        ServerName = other.ServerName;
      }
      if (other.idleTimeout_ != null) {
        if (idleTimeout_ == null) {
          idleTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        IdleTimeout.MergeFrom(other.IdleTimeout);
      }
      if (other.drainTimeout_ != null) {
        if (drainTimeout_ == null) {
          drainTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DrainTimeout.MergeFrom(other.DrainTimeout);
      }
      accessLog_.Add(other.accessLog_);
      if (other.useRemoteAddress_ != null) {
        if (useRemoteAddress_ == null || other.UseRemoteAddress != false) {
          UseRemoteAddress = other.UseRemoteAddress;
        }
      }
      if (other.XffNumTrustedHops != 0) {
        XffNumTrustedHops = other.XffNumTrustedHops;
      }
      if (other.generateRequestId_ != null) {
        if (generateRequestId_ == null || other.GenerateRequestId != false) {
          GenerateRequestId = other.GenerateRequestId;
        }
      }
      if (other.ForwardClientCertDetails != 0) {
        ForwardClientCertDetails = other.ForwardClientCertDetails;
      }
      if (other.setCurrentClientCertDetails_ != null) {
        if (setCurrentClientCertDetails_ == null) {
          setCurrentClientCertDetails_ = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.SetCurrentClientCertDetails();
        }
        SetCurrentClientCertDetails.MergeFrom(other.SetCurrentClientCertDetails);
      }
      if (other.Proxy100Continue != false) {
        Proxy100Continue = other.Proxy100Continue;
      }
      if (other.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) {
        RepresentIpv4RemoteAddressAsIpv4MappedIpv6 = other.RepresentIpv4RemoteAddressAsIpv4MappedIpv6;
      }
      switch (other.RouteSpecifierCase) {
        case RouteSpecifierOneofCase.Rds:
          if (Rds == null) {
            Rds = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.Rds();
          }
          Rds.MergeFrom(other.Rds);
          break;
        case RouteSpecifierOneofCase.RouteConfig:
          if (RouteConfig == null) {
            RouteConfig = new global::Envoy.Api.V2.RouteConfiguration();
          }
          RouteConfig.MergeFrom(other.RouteConfig);
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            codecType_ = (global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.CodecType) input.ReadEnum();
            break;
          }
          case 18: {
            StatPrefix = input.ReadString();
            break;
          }
          case 26: {
            global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.Rds subBuilder = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.Rds();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
              subBuilder.MergeFrom(Rds);
            }
            input.ReadMessage(subBuilder);
            Rds = subBuilder;
            break;
          }
          case 34: {
            global::Envoy.Api.V2.RouteConfiguration subBuilder = new global::Envoy.Api.V2.RouteConfiguration();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
              subBuilder.MergeFrom(RouteConfig);
            }
            input.ReadMessage(subBuilder);
            RouteConfig = subBuilder;
            break;
          }
          case 42: {
            httpFilters_.AddEntriesFrom(input, _repeated_httpFilters_codec);
            break;
          }
          case 50: {
            bool? value = _single_addUserAgent_codec.Read(input);
            if (addUserAgent_ == null || value != false) {
              AddUserAgent = value;
            }
            break;
          }
          case 58: {
            if (tracing_ == null) {
              tracing_ = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.Tracing();
            }
            input.ReadMessage(tracing_);
            break;
          }
          case 66: {
            if (httpProtocolOptions_ == null) {
              httpProtocolOptions_ = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
            }
            input.ReadMessage(httpProtocolOptions_);
            break;
          }
          case 74: {
            if (http2ProtocolOptions_ == null) {
              http2ProtocolOptions_ = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
            }
            input.ReadMessage(http2ProtocolOptions_);
            break;
          }
          case 82: {
            ServerName = input.ReadString();
            break;
          }
          case 90: {
            if (idleTimeout_ == null) {
              idleTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(idleTimeout_);
            break;
          }
          case 98: {
            if (drainTimeout_ == null) {
              drainTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(drainTimeout_);
            break;
          }
          case 106: {
            accessLog_.AddEntriesFrom(input, _repeated_accessLog_codec);
            break;
          }
          case 114: {
            bool? value = _single_useRemoteAddress_codec.Read(input);
            if (useRemoteAddress_ == null || value != false) {
              UseRemoteAddress = value;
            }
            break;
          }
          case 122: {
            bool? value = _single_generateRequestId_codec.Read(input);
            if (generateRequestId_ == null || value != false) {
              GenerateRequestId = value;
            }
            break;
          }
          case 128: {
            forwardClientCertDetails_ = (global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.ForwardClientCertDetails) input.ReadEnum();
            break;
          }
          case 138: {
            if (setCurrentClientCertDetails_ == null) {
              setCurrentClientCertDetails_ = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.SetCurrentClientCertDetails();
            }
            input.ReadMessage(setCurrentClientCertDetails_);
            break;
          }
          case 144: {
            Proxy100Continue = input.ReadBool();
            break;
          }
          case 152: {
            XffNumTrustedHops = input.ReadUInt32();
            break;
          }
          case 160: {
            RepresentIpv4RemoteAddressAsIpv4MappedIpv6 = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the HttpConnectionManager message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum CodecType {
        /// <summary>
        /// For every new connection, the connection manager will determine which
        /// codec to use. This mode supports both ALPN for TLS listeners as well as
        /// protocol inference for plaintext listeners. If ALPN data is available, it
        /// is preferred, otherwise protocol inference is used. In almost all cases,
        /// this is the right option to choose for this setting.
        /// </summary>
        [pbr::OriginalName("AUTO")] Auto = 0,
        /// <summary>
        /// The connection manager will assume that the client is speaking HTTP/1.1.
        /// </summary>
        [pbr::OriginalName("HTTP1")] Http1 = 1,
        /// <summary>
        /// The connection manager will assume that the client is speaking HTTP/2
        /// (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
        /// Prior knowledge is allowed).
        /// </summary>
        [pbr::OriginalName("HTTP2")] Http2 = 2,
      }

      /// <summary>
      /// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
      /// header.
      /// </summary>
      public enum ForwardClientCertDetails {
        /// <summary>
        /// Do not send the XFCC header to the next hop. This is the default value.
        /// </summary>
        [pbr::OriginalName("SANITIZE")] Sanitize = 0,
        /// <summary>
        /// When the client connection is mTLS (Mutual TLS), forward the XFCC header
        /// in the request.
        /// </summary>
        [pbr::OriginalName("FORWARD_ONLY")] ForwardOnly = 1,
        /// <summary>
        /// When the client connection is mTLS, append the client certificate
        /// information to the request’s XFCC header and forward it.
        /// </summary>
        [pbr::OriginalName("APPEND_FORWARD")] AppendForward = 2,
        /// <summary>
        /// When the client connection is mTLS, reset the XFCC header with the client
        /// certificate information and send it to the next hop.
        /// </summary>
        [pbr::OriginalName("SANITIZE_SET")] SanitizeSet = 3,
        /// <summary>
        /// Always forward the XFCC header in the request, regardless of whether the
        /// client connection is mTLS.
        /// </summary>
        [pbr::OriginalName("ALWAYS_FORWARD_ONLY")] AlwaysForwardOnly = 4,
      }

      public sealed partial class Tracing : pb::IMessage<Tracing> {
        private static readonly pb::MessageParser<Tracing> _parser = new pb::MessageParser<Tracing>(() => new Tracing());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Tracing> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tracing() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tracing(Tracing other) : this() {
          operationName_ = other.operationName_;
          requestHeadersForTags_ = other.requestHeadersForTags_.Clone();
          ClientSampling = other.clientSampling_ != null ? other.ClientSampling.Clone() : null;
          RandomSampling = other.randomSampling_ != null ? other.RandomSampling.Clone() : null;
          OverallSampling = other.overallSampling_ != null ? other.OverallSampling.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tracing Clone() {
          return new Tracing(this);
        }

        /// <summary>Field number for the "operation_name" field.</summary>
        public const int OperationNameFieldNumber = 1;
        private global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.Tracing.Types.OperationName operationName_ = 0;
        /// <summary>
        /// The span name will be derived from this field.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.Tracing.Types.OperationName OperationName {
          get { return operationName_; }
          set {
            operationName_ = value;
          }
        }

        /// <summary>Field number for the "request_headers_for_tags" field.</summary>
        public const int RequestHeadersForTagsFieldNumber = 2;
        private static readonly pb::FieldCodec<string> _repeated_requestHeadersForTags_codec
            = pb::FieldCodec.ForString(18);
        private readonly pbc::RepeatedField<string> requestHeadersForTags_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// A list of header names used to create tags for the active span. The header name is used to
        /// populate the tag name, and the header value is used to populate the tag value. The tag is
        /// created if the specified header name is present in the request's headers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> RequestHeadersForTags {
          get { return requestHeadersForTags_; }
        }

        /// <summary>Field number for the "client_sampling" field.</summary>
        public const int ClientSamplingFieldNumber = 3;
        private global::Envoy.Api.V2.Core.Percent clientSampling_;
        /// <summary>
        /// Target percentage of requests managed by this HTTP connection manager that will be force
        /// traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id>`
        /// header is set. This field is a direct analog for the runtime variable
        /// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
        /// &lt;config_http_conn_man_runtime>`.
        /// Default: 100%
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Core.Percent ClientSampling {
          get { return clientSampling_; }
          set {
            clientSampling_ = value;
          }
        }

        /// <summary>Field number for the "random_sampling" field.</summary>
        public const int RandomSamplingFieldNumber = 4;
        private global::Envoy.Api.V2.Core.Percent randomSampling_;
        /// <summary>
        /// Target percentage of requests managed by this HTTP connection manager that will be randomly
        /// selected for trace generation, if not requested by the client or not forced. This field is
        /// a direct analog for the runtime variable 'tracing.random_sampling' in the
        /// :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime>`.
        /// Default: 100%
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Core.Percent RandomSampling {
          get { return randomSampling_; }
          set {
            randomSampling_ = value;
          }
        }

        /// <summary>Field number for the "overall_sampling" field.</summary>
        public const int OverallSamplingFieldNumber = 5;
        private global::Envoy.Api.V2.Core.Percent overallSampling_;
        /// <summary>
        /// Target percentage of requests managed by this HTTP connection manager that will be traced
        /// after all other sampling checks have been applied (client-directed, force tracing, random
        /// sampling). This field functions as an upper limit on the total configured sampling rate. For
        /// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
        /// of client requests with the appropriate headers to be force traced. This field is a direct
        /// analog for the runtime variable 'tracing.global_enabled' in the
        /// :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime>`.
        /// Default: 100%
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Core.Percent OverallSampling {
          get { return overallSampling_; }
          set {
            overallSampling_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Tracing);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Tracing other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (OperationName != other.OperationName) return false;
          if(!requestHeadersForTags_.Equals(other.requestHeadersForTags_)) return false;
          if (!object.Equals(ClientSampling, other.ClientSampling)) return false;
          if (!object.Equals(RandomSampling, other.RandomSampling)) return false;
          if (!object.Equals(OverallSampling, other.OverallSampling)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (OperationName != 0) hash ^= OperationName.GetHashCode();
          hash ^= requestHeadersForTags_.GetHashCode();
          if (clientSampling_ != null) hash ^= ClientSampling.GetHashCode();
          if (randomSampling_ != null) hash ^= RandomSampling.GetHashCode();
          if (overallSampling_ != null) hash ^= OverallSampling.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (OperationName != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) OperationName);
          }
          requestHeadersForTags_.WriteTo(output, _repeated_requestHeadersForTags_codec);
          if (clientSampling_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(ClientSampling);
          }
          if (randomSampling_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(RandomSampling);
          }
          if (overallSampling_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(OverallSampling);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (OperationName != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OperationName);
          }
          size += requestHeadersForTags_.CalculateSize(_repeated_requestHeadersForTags_codec);
          if (clientSampling_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientSampling);
          }
          if (randomSampling_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomSampling);
          }
          if (overallSampling_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OverallSampling);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Tracing other) {
          if (other == null) {
            return;
          }
          if (other.OperationName != 0) {
            OperationName = other.OperationName;
          }
          requestHeadersForTags_.Add(other.requestHeadersForTags_);
          if (other.clientSampling_ != null) {
            if (clientSampling_ == null) {
              clientSampling_ = new global::Envoy.Api.V2.Core.Percent();
            }
            ClientSampling.MergeFrom(other.ClientSampling);
          }
          if (other.randomSampling_ != null) {
            if (randomSampling_ == null) {
              randomSampling_ = new global::Envoy.Api.V2.Core.Percent();
            }
            RandomSampling.MergeFrom(other.RandomSampling);
          }
          if (other.overallSampling_ != null) {
            if (overallSampling_ == null) {
              overallSampling_ = new global::Envoy.Api.V2.Core.Percent();
            }
            OverallSampling.MergeFrom(other.OverallSampling);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                operationName_ = (global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Types.Tracing.Types.OperationName) input.ReadEnum();
                break;
              }
              case 18: {
                requestHeadersForTags_.AddEntriesFrom(input, _repeated_requestHeadersForTags_codec);
                break;
              }
              case 26: {
                if (clientSampling_ == null) {
                  clientSampling_ = new global::Envoy.Api.V2.Core.Percent();
                }
                input.ReadMessage(clientSampling_);
                break;
              }
              case 34: {
                if (randomSampling_ == null) {
                  randomSampling_ = new global::Envoy.Api.V2.Core.Percent();
                }
                input.ReadMessage(randomSampling_);
                break;
              }
              case 42: {
                if (overallSampling_ == null) {
                  overallSampling_ = new global::Envoy.Api.V2.Core.Percent();
                }
                input.ReadMessage(overallSampling_);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Tracing message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum OperationName {
            /// <summary>
            /// The HTTP listener is used for ingress/incoming requests.
            /// </summary>
            [pbr::OriginalName("INGRESS")] Ingress = 0,
            /// <summary>
            /// The HTTP listener is used for egress/outgoing requests.
            /// </summary>
            [pbr::OriginalName("EGRESS")] Egress = 1,
          }

        }
        #endregion

      }

      public sealed partial class SetCurrentClientCertDetails : pb::IMessage<SetCurrentClientCertDetails> {
        private static readonly pb::MessageParser<SetCurrentClientCertDetails> _parser = new pb::MessageParser<SetCurrentClientCertDetails>(() => new SetCurrentClientCertDetails());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SetCurrentClientCertDetails> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManager.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SetCurrentClientCertDetails() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SetCurrentClientCertDetails(SetCurrentClientCertDetails other) : this() {
          Subject = other.Subject;
          San = other.San;
          cert_ = other.cert_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SetCurrentClientCertDetails Clone() {
          return new SetCurrentClientCertDetails(this);
        }

        /// <summary>Field number for the "subject" field.</summary>
        public const int SubjectFieldNumber = 1;
        private static readonly pb::FieldCodec<bool?> _single_subject_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
        private bool? subject_;
        /// <summary>
        /// Whether to forward the subject of the client cert. Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool? Subject {
          get { return subject_; }
          set {
            subject_ = value;
          }
        }

        /// <summary>Field number for the "san" field.</summary>
        public const int SanFieldNumber = 2;
        private static readonly pb::FieldCodec<bool?> _single_san_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
        private bool? san_;
        /// <summary>
        /// Whether to forward the SAN of the client cert. Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool? San {
          get { return san_; }
          set {
            san_ = value;
          }
        }

        /// <summary>Field number for the "cert" field.</summary>
        public const int CertFieldNumber = 3;
        private bool cert_;
        /// <summary>
        /// [#not-implemented-hide:]
        /// Whether to forward the entire client cert in base64 encoded format. Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Cert {
          get { return cert_; }
          set {
            cert_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SetCurrentClientCertDetails);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SetCurrentClientCertDetails other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Subject != other.Subject) return false;
          if (San != other.San) return false;
          if (Cert != other.Cert) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (subject_ != null) hash ^= Subject.GetHashCode();
          if (san_ != null) hash ^= San.GetHashCode();
          if (Cert != false) hash ^= Cert.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (subject_ != null) {
            _single_subject_codec.WriteTagAndValue(output, Subject);
          }
          if (san_ != null) {
            _single_san_codec.WriteTagAndValue(output, San);
          }
          if (Cert != false) {
            output.WriteRawTag(24);
            output.WriteBool(Cert);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (subject_ != null) {
            size += _single_subject_codec.CalculateSizeWithTag(Subject);
          }
          if (san_ != null) {
            size += _single_san_codec.CalculateSizeWithTag(San);
          }
          if (Cert != false) {
            size += 1 + 1;
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SetCurrentClientCertDetails other) {
          if (other == null) {
            return;
          }
          if (other.subject_ != null) {
            if (subject_ == null || other.Subject != false) {
              Subject = other.Subject;
            }
          }
          if (other.san_ != null) {
            if (san_ == null || other.San != false) {
              San = other.San;
            }
          }
          if (other.Cert != false) {
            Cert = other.Cert;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                bool? value = _single_subject_codec.Read(input);
                if (subject_ == null || value != false) {
                  Subject = value;
                }
                break;
              }
              case 18: {
                bool? value = _single_san_codec.Read(input);
                if (san_ == null || value != false) {
                  San = value;
                }
                break;
              }
              case 24: {
                Cert = input.ReadBool();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class Rds : pb::IMessage<Rds> {
    private static readonly pb::MessageParser<Rds> _parser = new pb::MessageParser<Rds>(() => new Rds());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Rds> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManagerReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Rds() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Rds(Rds other) : this() {
      ConfigSource = other.configSource_ != null ? other.ConfigSource.Clone() : null;
      routeConfigName_ = other.routeConfigName_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Rds Clone() {
      return new Rds(this);
    }

    /// <summary>Field number for the "config_source" field.</summary>
    public const int ConfigSourceFieldNumber = 1;
    private global::Envoy.Api.V2.Core.ConfigSource configSource_;
    /// <summary>
    /// Configuration source specifier for RDS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.ConfigSource ConfigSource {
      get { return configSource_; }
      set {
        configSource_ = value;
      }
    }

    /// <summary>Field number for the "route_config_name" field.</summary>
    public const int RouteConfigNameFieldNumber = 2;
    private string routeConfigName_ = "";
    /// <summary>
    /// The name of the route configuration. This name will be passed to the RDS
    /// API. This allows an Envoy configuration with multiple HTTP listeners (and
    /// associated HTTP connection manager filters) to use different route
    /// configurations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RouteConfigName {
      get { return routeConfigName_; }
      set {
        routeConfigName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Rds);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Rds other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ConfigSource, other.ConfigSource)) return false;
      if (RouteConfigName != other.RouteConfigName) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (configSource_ != null) hash ^= ConfigSource.GetHashCode();
      if (RouteConfigName.Length != 0) hash ^= RouteConfigName.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (configSource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ConfigSource);
      }
      if (RouteConfigName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RouteConfigName);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (configSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigSource);
      }
      if (RouteConfigName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteConfigName);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Rds other) {
      if (other == null) {
        return;
      }
      if (other.configSource_ != null) {
        if (configSource_ == null) {
          configSource_ = new global::Envoy.Api.V2.Core.ConfigSource();
        }
        ConfigSource.MergeFrom(other.ConfigSource);
      }
      if (other.RouteConfigName.Length != 0) {
        RouteConfigName = other.RouteConfigName;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (configSource_ == null) {
              configSource_ = new global::Envoy.Api.V2.Core.ConfigSource();
            }
            input.ReadMessage(configSource_);
            break;
          }
          case 18: {
            RouteConfigName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class HttpFilter : pb::IMessage<HttpFilter> {
    private static readonly pb::MessageParser<HttpFilter> _parser = new pb::MessageParser<HttpFilter>(() => new HttpFilter());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HttpFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpConnectionManagerReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpFilter(HttpFilter other) : this() {
      name_ = other.name_;
      Config = other.config_ != null ? other.Config.Clone() : null;
      DeprecatedV1 = other.deprecatedV1_ != null ? other.DeprecatedV1.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpFilter Clone() {
      return new HttpFilter(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the filter to instantiate. The name must match a supported
    /// filter. The built-in filters are:
    ///
    /// [#comment:TODO(mattklein123): Auto generate the following list]
    /// * :ref:`envoy.buffer &lt;config_http_filters_buffer>`
    /// * :ref:`envoy.cors &lt;config_http_filters_cors>`
    /// * :ref:`envoy.fault &lt;config_http_filters_fault_injection>`
    /// * :ref:`envoy.gzip &lt;config_http_filters_gzip>`
    /// * :ref:`envoy.http_dynamo_filter &lt;config_http_filters_dynamo>`
    /// * :ref:`envoy.grpc_http1_bridge &lt;config_http_filters_grpc_bridge>`
    /// * :ref:`envoy.grpc_json_transcoder &lt;config_http_filters_grpc_json_transcoder>`
    /// * :ref:`envoy.grpc_web &lt;config_http_filters_grpc_web>`
    /// * :ref:`envoy.health_check &lt;config_http_filters_health_check>`
    /// * :ref:`envoy.lua &lt;config_http_filters_lua>`
    /// * :ref:`envoy.rate_limit &lt;config_http_filters_rate_limit>`
    /// * :ref:`envoy.router &lt;config_http_filters_router>`
    /// * :ref:`envoy.squash &lt;config_http_filters_squash>`
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Struct config_;
    /// <summary>
    /// Filter specific configuration which depends on the filter being
    /// instantiated. See the supported filters for further documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Struct Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    /// <summary>Field number for the "deprecated_v1" field.</summary>
    public const int DeprecatedV1FieldNumber = 3;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter.Types.DeprecatedV1 deprecatedV1_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// This is hidden as type has been deprecated and is no longer required.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter.Types.DeprecatedV1 DeprecatedV1 {
      get { return deprecatedV1_; }
      set {
        deprecatedV1_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HttpFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HttpFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Config, other.Config)) return false;
      if (!object.Equals(DeprecatedV1, other.DeprecatedV1)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (config_ != null) hash ^= Config.GetHashCode();
      if (deprecatedV1_ != null) hash ^= DeprecatedV1.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (config_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Config);
      }
      if (deprecatedV1_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(DeprecatedV1);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (deprecatedV1_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeprecatedV1);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HttpFilter other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          config_ = new global::Google.Protobuf.WellKnownTypes.Struct();
        }
        Config.MergeFrom(other.Config);
      }
      if (other.deprecatedV1_ != null) {
        if (deprecatedV1_ == null) {
          deprecatedV1_ = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter.Types.DeprecatedV1();
        }
        DeprecatedV1.MergeFrom(other.DeprecatedV1);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (config_ == null) {
              config_ = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            input.ReadMessage(config_);
            break;
          }
          case 26: {
            if (deprecatedV1_ == null) {
              deprecatedV1_ = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter.Types.DeprecatedV1();
            }
            input.ReadMessage(deprecatedV1_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the HttpFilter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// [#not-implemented-hide:]
      /// This is hidden as type has been deprecated and is no longer required.
      /// </summary>
      public sealed partial class DeprecatedV1 : pb::IMessage<DeprecatedV1> {
        private static readonly pb::MessageParser<DeprecatedV1> _parser = new pb::MessageParser<DeprecatedV1>(() => new DeprecatedV1());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DeprecatedV1> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V2.HttpFilter.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1(DeprecatedV1 other) : this() {
          type_ = other.type_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1 Clone() {
          return new DeprecatedV1(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private string type_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Type {
          get { return type_; }
          set {
            type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DeprecatedV1);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DeprecatedV1 other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Type.Length != 0) hash ^= Type.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Type.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Type);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Type.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DeprecatedV1 other) {
          if (other == null) {
            return;
          }
          if (other.Type.Length != 0) {
            Type = other.Type;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Type = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
